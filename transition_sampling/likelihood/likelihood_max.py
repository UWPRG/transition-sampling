"""
Likelihood maximization of aimless shooting results.
"""
from __future__ import annotations

from itertools import combinations
from typing import Union

import numpy as np
import pandas as pd

from . import optimize


class Maximizer:
    """
    Class for finding the best reaction coordinate with likelihood maximization.

    Utilizes the results of aimless shooting and colvar calculation to determine
    the optimum reaction coordinate by maximizing the likelihood of accepted
    being on a transition path and rejected states being off it. See
    `optimization.optimize` for more details on the maximization.

    This is used to iteratively perform the maximization for all combinations
    of CVs starting from a single CV and going to longer combinations if
    adding another yields a statistically significant increase in likelihood.
    Construct an instance and call `maximize`.

    Parameters
    ----------
    colvars_file
        File path to the CVs calculated with plumed in the default format.
    csv_file
        File path to the cvs generated by aimless shooting that corresponds to
        the colvars_file
    niter
        Number of local optimizations to determine a global optimum. This can
        either be a single integer or a list of integers with the same length
        as the number of CVs. The list gives the number of optimizations to do
        for each combination length - it may be beneficial to have less
        iterations for higher lengths of CVs if the optimization becomes too
        long
    use_jac
        If true, the analytical jacobian will be calculated and used in the
        optimization. Usually results in some speedup.

    Attributes
    ----------
    colvars : pd.DataFrame
        A DataFrame of all the collective variables loaded from `colvars_file`
    metadata : pd.DataFrame
        A DataFrame containing the metadata of each state in `colvars_file`,
        specifically if each was accepted or not.
    niter : list[int]
        how many local optimizations to do for each global optimization with
        a given number of cvs. Length == # of cvs
    use_jac : bool
        True if the analytical jacobian should be used in optimization
    """

    def __init__(self, colvars_file: str, csv_file: str,
                 niter: Union[int, list[int]] = 100, use_jac: bool = True):

        # Skip header field that has weird plumed names, cast time to ints, set
        # as the index to compare to the metadata indices.
        cv_names = self._read_header(colvars_file)
        self.colvars = pd.read_csv(colvars_file, skiprows=1, sep="\s+",
                                   names=cv_names).astype({'time': 'int64'}).set_index('time')

        self.metadata = pd.read_csv(csv_file)

        if self.colvars.shape[0] != self.metadata.shape[0]:
            raise ValueError("Number of states in colvars != number of metadata")

        # Initialize the niter list
        try:
            iter(niter)
            if len(niter) != len(cv_names):
                raise ValueError("There must be a value in niter for each cv")

            self.niter = niter

        except TypeError:
            self.niter = [niter] * len(cv_names)

        self.use_jac = use_jac

    def maximize(self) -> tuple[tuple, np.ndarray]:
        """
        Find the combination of CVs that maximize the likelihood of this data.

        Only adds more CVs if they result in a statistically significant
        increase.

        Returns
        -------
        The CV names that represent the maximum and the parameters that optimize
        it. The parameters list corresponds to [p0, alpha0, <weights of each CV>]
        """
        available_colvars = self.colvars.columns
        improvement = 0.5 * np.log(self.colvars.shape[0])

        last_obj = np.NINF
        last_sol = None
        last_combination = None
        num_cvs = 1

        # Do while loop according to PEP 315. Will at least evaluate all single
        # CVs and all pairs of CVs.
        while True:
            max_obj = np.NINF
            max_combination = None
            max_sol = None

            # For each possible combination with a given number of cvs, find the
            # one with the maximum likelihood
            for cv_combination in combinations(available_colvars, num_cvs):
                obj, sol = self._optimize_set(cv_combination)

                print(f"obj for {cv_combination}: {obj}")

                if obj > max_obj:
                    max_obj = obj
                    max_sol = sol
                    max_combination = cv_combination

            print(f"Max for {num_cvs}: obj for {max_combination}: {max_obj}")

            # See if that combination improved enough over the last one. If yes,
            # continue to do more
            if max_obj - last_obj > improvement:
                last_obj = max_obj
                last_sol = max_sol
                last_combination = max_combination
                print("Good enough to continue")

                # Exit if there are no more CVs to maximize
                if num_cvs == len(available_colvars):
                    break
                else:
                    num_cvs += 1

            else:
                break

        print("Exiting")

        return last_combination, last_sol

    def _optimize_set(self, cvs: tuple) -> tuple[float, np.ndarray]:
        """
        Optimize a set of cvs and return the maximum likelihood and solution

        Parameters
        ----------
        cvs
            Tuple of cv names to be included

        Returns
        -------
        The objective function of the optimized solution and the solution
        """
        niter = self.niter[len(cvs) - 1]

        cv_data = self.colvars.loc[:, cvs].values
        accepted_data = self.metadata.loc[:, 'accepted'].values

        sol = optimize(cv_data, accepted_data, niter, self.use_jac)

        # objective function comes out as a minimizer, take negative to make
        # maximizer
        return -1 * sol[0], sol[1]

    @staticmethod
    def _read_header(colvars_file: str) -> list[str]:
        """
        Get the CV names from the plumed header, bypassing #! and FIELDS

        Parameters
        ----------
        colvars_file
            Path to plumed output file to read from

        Returns
        -------
        A list of headers, excluding the first two #! and FIELDS, but including
        'time'
        """
        with open(colvars_file, 'r') as f:
            line = f.readline()

        cols = line.split()
        return cols[2:]
