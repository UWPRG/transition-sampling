"""
Likelihood maximization of aimless shooting results.
"""
from __future__ import annotations

from itertools import combinations
from typing import Union

import numpy as np
import pandas as pd

from . import optimize


class Maximizer:
    """
    Class for finding the best reaction coordinate with likelihood maximization.

    Utilizes the results of aimless shooting and colvar calculation to determine
    the optimum reaction coordinate by maximizing the likelihood of accepted
    being on a transition path and rejected states being off it. See
    `optimization.optimize` for more details on the maximization.

    This is used to iteratively perform the maximization for all combinations
    of CVs starting from a single CV and going to longer combinations if
    adding another yields a statistically significant increase in likelihood.
    Construct an instance and call `maximize`.

    Parameters
    ----------
    colvars_file
        File path to the CVs calculated with plumed in the default format.
    csv_file
        File path to the cvs generated by aimless shooting that corresponds to
        the colvars_file
    niter
        Number of local optimizations to determine a global optimum. This can
        either be a single integer or a list of integers with the same length
        as the number of CVs. The list gives the number of optimizations to do
        for each combination length - it may be beneficial to have less
        iterations for higher lengths of CVs if the optimization becomes too
        long
    use_jac
        If true, the analytical jacobian will be calculated and used in the
        optimization. Usually results in some speedup.

    Attributes
    ----------
    colvars : pd.DataFrame
        A DataFrame of all the collective variables loaded from `colvars_file`
    metadata : pd.DataFrame
        A DataFrame containing the metadata of each state in `colvars_file`,
        specifically if each was accepted or not.
    niter : list[int]
        how many local optimizations to do for each global optimization with
        a given number of cvs. Length == # of cvs
    use_jac : bool
        True if the analytical jacobian should be used in optimization

    Raises
    ------
    ValueError
        If the number of states in the colvars_file != number of states in
        the csv_file
    """

    def __init__(self, colvars_file: str, csv_file: str,
                 niter: Union[int, list[int]] = 100, use_jac: bool = True):

        # Skip header field that has weird plumed names, cast time to ints, set
        # as the index to compare to the metadata indices.
        cv_names = self._read_header(colvars_file)
        self.colvars = pd.read_csv(colvars_file, skiprows=1, sep="\s+",
                                   names=cv_names).astype(
            {'time': 'int64'}).set_index('time')

        self.metadata = pd.read_csv(csv_file)

        if self.colvars.shape[0] != self.metadata.shape[0]:
            raise ValueError(
                "Number of states in colvars != number of metadata")

        # Initialize the niter list
        try:
            iter(niter)
            if len(niter) != len(cv_names):
                raise ValueError("There must be a value in niter for each cv")

            self.niter = niter

        except TypeError:
            self.niter = [niter] * len(cv_names)

        self.use_jac = use_jac

    def maximize(self, max_num_cvs: int = None) -> MaximizerSolution:
        """
        Find the combination of CVs that maximize the likelihood of this data.

        Only adds more CVs if they result in a statistically significant
        increase.

        Parameters
        ----------
        max_num_cvs
            The maximum number of CVs in a combination to evaluate (inclusive).
            If this number is reached before the statistical threshold for adding
            new CVs is, this function returns early. Set to None to set no limit

        Returns
        -------
        All values for each tested combination, as well as the maximum
        significant combination. See `MaximizerSolution`
        """
        available_colvars = self.colvars.columns
        num_cvs = 1
        result = MaximizerSolution(0.5 * np.log(self.colvars.shape[0]))

        if max_num_cvs is None:
            max_num_cvs = len(available_colvars)

        # Do while loop according to PEP 315. Will at least evaluate all single
        # CVs and all pairs of CVs given appropriate max_num_cvs
        while num_cvs <= max_num_cvs:
            # Empty solution to compare initially
            max_sol = SingleSolution(None, np.NINF, None)
            result.combinations[num_cvs] = {}

            # For each possible combination with a given number of cvs, find the
            # one with the maximum likelihood
            for cv_comb in combinations(available_colvars, num_cvs):
                cur_sol = self._optimize_set(cv_comb)
                result.combinations[num_cvs][frozenset(cv_comb)] = cur_sol

                if cur_sol.obj > max_sol.obj:
                    max_sol = cur_sol

            # See if that combination improved enough over the last one. If yes,
            # continue to do more
            if max_sol.obj - result.max.obj > result.req_improvement:
                result.max = max_sol

                # Exit if there are no more CVs to maximize
                if num_cvs == len(available_colvars):
                    break
                else:
                    num_cvs += 1

            else:
                break

        return result

    def _optimize_set(self, cvs: tuple) -> SingleSolution:
        """
        Optimize a set of cvs and return the maximum likelihood and solution

        Parameters
        ----------
        cvs
            Tuple of cv names to be included

        Returns
        -------
        A SingleSolution representation of the optimized result
        """
        niter = self.niter[len(cvs) - 1]

        cv_data = self.colvars.loc[:, cvs].values
        accepted_data = self.metadata.loc[:, 'accepted'].values

        sol = optimize(cv_data, accepted_data, niter, self.use_jac)

        # objective function comes out as a minimizer, take negative to make
        # maximizer
        return SingleSolution(cvs, -1 * sol[0], sol[1])

    @staticmethod
    def _read_header(colvars_file: str) -> list[str]:
        """
        Get the CV names from the plumed header, bypassing #! and FIELDS

        Parameters
        ----------
        colvars_file
            Path to plumed output file to read from

        Returns
        -------
        A list of headers, excluding the first two #! and FIELDS, but including
        'time'
        """
        with open(colvars_file, 'r') as f:
            line = f.readline()

        cols = line.split()
        return cols[2:]


class MaximizerSolution:
    """
    Wrapper class to carry results for all tested combinations in maximization.

    Parameters
    ----------
    req_improvement
        The required improvement of the objective function for an additional CV
        to be added to max

    Attributes
    ----------
    combinations : dict[int: dict[frozenset: SingleSolution]]
        A dictionary representing the solution to all tested combinations. The
        first key indicates the length of the combination. Within that
        dictionary, the keys are sets of CV combinations, with values being a
        the SingleSolution representation of the optimization.

    max : SingleSolution
        The solution that has the maximum likelihood while still being
        significant as determined by `req_improvement` to add another CV

    req_improvement : float
        The required improvement of the objective function for an additional CV
        to be added to max
    """

    def __init__(self, req_improvement: float):
        self.combinations = {}
        self.max = SingleSolution(None, np.NINF, None)
        self.req_improvement = req_improvement

    def to_csv(self, file: str) -> None:
        """
        Write the contents to a CSV. Non-present CVs get a NaN weight.

        Parameters
        ----------
        file
            The filename to write the CSV to. Will append if a file is already
            present
        """
        df = self.to_dataframe()
        with open(file, "a") as f:
            df.to_csv(f)

    def to_dataframe(self) -> pd.DataFrame:
        """
        Turn the contents into a rectangular data frame, one row per combination

        In order to keep a rectangular format, cvs that aren't in a specific
        combination get a weight of NaN. The objective function and all weights
        are

        Returns
        -------
        DataFrame with combination results as rows and columns of
        [n_cvs, obj_val, p0, alpha0, <weight of each CV>]
        """
        df_list = []
        for length_dict in self.combinations.values():
            for sol in length_dict.values():
                cur_dict = {"n_cvs": len(sol.comb), "obj_val": sol.obj,
                            "p0": sol.sol[0], "alpha0": sol.sol[1]}
                for i, cv in enumerate(sol.comb):
                    cur_dict[cv] = sol.sol[i + 2]
                df_list.append(cur_dict)
        return pd.DataFrame(df_list)


class SingleSolution:
    """
    Carries the result of a single CV combination optimization.

    Parameters
    ----------
    comb
        An ordered tuple of CVs that this solution represents
    obj
        The objective function of this result
    sol
        The optimized solution. An ordered array of
        [`p0`, `alpha0`, `coeffs_for_each_CV in comb`]

    Attributes
    ----------
    See Parameters
    """

    def __init__(self, comb: tuple, obj: float, sol: np.ndarray):
        self.comb = comb
        self.obj = obj
        self.sol = sol
